diff --git a/configure.ac b/configure.ac
index 7e09201..aa5883d 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2881,9 +2881,12 @@ AC_ARG_ENABLE(mpc,
   [  --enable-mpc            Mpc demux support (default enabled)])
 if test "${enable_mpc}" != "no"
 then
-  AC_CHECK_HEADERS(mpcdec/mpcdec.h, [
+  AC_CHECK_HEADERS([mpc/mpcdec.h], [
     VLC_ADD_PLUGIN([mpc])
-    VLC_ADD_LIBS([mpc],[-lmpcdec])])
+    VLC_ADD_LIBS([mpc],[-lmpcdec])],
+    [AC_CHECK_HEADERS([mpcdec/mpcdec.h], [
+    VLC_ADD_PLUGIN([mpc])
+    VLC_ADD_LIBS([mpc],[-lmpcdec])])])
 fi
 
 dnl
diff --git a/modules/demux/mpc.c b/modules/demux/mpc.c
index 60fe5c5..5b36cb0 100644
--- a/modules/demux/mpc.c
+++ b/modules/demux/mpc.c
@@ -35,7 +35,11 @@
 #include <vlc_codec.h>
 #include <math.h>
 
+#ifdef HAVE_MPC_MPCDEC_H
+#include <mpc/mpcdec.h>
+#else
 #include <mpcdec/mpcdec.h>
+#endif
 
 /* TODO:
  *  - test stream version 4..6
@@ -74,7 +78,11 @@ struct demux_sys_t
     es_out_id_t *p_es;
 
     /* */
+#ifndef HAVE_MPC_MPCDEC_H
     mpc_decoder    decoder;
+#else
+    mpc_demux     *decoder;
+#endif
     mpc_reader     reader;
     mpc_streaminfo info;
 
@@ -82,11 +90,19 @@ struct demux_sys_t
     int64_t        i_position;
 };
 
+#ifndef HAVE_MPC_MPCDEC_H
 mpc_int32_t ReaderRead( void *p_private, void *dst, mpc_int32_t i_size );
 mpc_bool_t  ReaderSeek( void *p_private, mpc_int32_t i_offset );
 mpc_int32_t ReaderTell( void *p_private);
 mpc_int32_t ReaderGetSize( void *p_private );
 mpc_bool_t  ReaderCanSeek( void *p_private );
+#else
+mpc_int32_t ReaderRead( mpc_reader *p_private, void *dst, mpc_int32_t i_size );
+mpc_bool_t  ReaderSeek( mpc_reader *p_private, mpc_int32_t i_offset );
+mpc_int32_t ReaderTell( mpc_reader *p_private);
+mpc_int32_t ReaderGetSize( mpc_reader *p_private );
+mpc_bool_t  ReaderCanSeek( mpc_reader *p_private );
+#endif
 
 /*****************************************************************************
  * Open: initializes ES structures
@@ -101,7 +117,12 @@ static int Open( vlc_object_t * p_this )
     if( stream_Peek( p_demux->s, &p_peek, 4 ) < 4 )
         return VLC_EGENERIC;
 
-    if( memcmp( p_peek, "MP+", 3 ) )
+    if( memcmp( p_peek, "MP+", 3 )
+#ifdef HAVE_MPC_MPCDEC_H
+	/* SV8 format */
+	&& memcmp( p_peek, "MPCK", 4 )
+#endif
+	)
     {
         /* for v4..6 we check extension file */
         const int i_version = (GetDWLE( p_peek ) >> 11)&0x3ff;
@@ -132,6 +153,7 @@ static int Open( vlc_object_t * p_this )
     p_sys->reader.canseek = ReaderCanSeek;
     p_sys->reader.data = p_demux;
 
+#ifndef HAVE_MPC_MPCDEC_H
     /* Load info */
     mpc_streaminfo_init( &p_sys->info );
     if( mpc_streaminfo_read( &p_sys->info, &p_sys->reader ) != ERROR_CODE_OK )
@@ -149,6 +171,16 @@ static int Open( vlc_object_t * p_this )
         free( p_sys );
         return VLC_EGENERIC;
     }
+#else
+    p_sys->decoder = mpc_demux_init( &p_sys->reader );
+    if( !p_sys->decoder )
+    {
+	free( p_sys );
+	return VLC_EGENERIC;
+    }
+
+    mpc_demux_get_info( p_sys->decoder, &p_sys->info );
+#endif
 
     /* Fill p_demux fields */
     p_demux->pf_demux = Demux;
@@ -199,6 +231,10 @@ static void Close( vlc_object_t * p_this )
     demux_t        *p_demux = (demux_t*)p_this;
     demux_sys_t    *p_sys = p_demux->p_sys;
 
+#ifdef HAVE_MPC_MPCDEC_H
+    if( p_sys->decoder )
+	mpc_demux_exit( p_sys->decoder );
+#endif
     free( p_sys );
 }
 
@@ -212,9 +248,14 @@ static int Demux( demux_t *p_demux )
     demux_sys_t *p_sys = p_demux->p_sys;
     block_t     *p_data;
     int i_ret;
+#ifdef HAVE_MPC_MPCDEC_H
+    mpc_frame_info frame;
+    mpc_status err;
+#endif
 
     p_data = block_New( p_demux,
                         MPC_DECODER_BUFFER_LENGTH*sizeof(MPC_SAMPLE_FORMAT) );
+#ifndef HAVE_MPC_MPCDEC_H
     i_ret = mpc_decoder_decode( &p_sys->decoder,
                                (MPC_SAMPLE_FORMAT*)p_data->p_buffer,
                                NULL, NULL );
@@ -223,6 +264,22 @@ static int Demux( demux_t *p_demux )
         block_Release( p_data );
         return i_ret < 0 ? -1 : 0;
     }
+#else
+    frame.buffer = (MPC_SAMPLE_FORMAT*)p_data->p_buffer;
+    err = mpc_demux_decode( p_sys->decoder, &frame );
+    if( err != MPC_STATUS_OK )
+    {
+	block_Release( p_data );
+	return -1;
+    }
+    else if( frame.bits == -1 )
+    {
+	block_Release( p_data );
+	return 0;
+    }
+
+    i_ret = frame.samples;
+#endif
 
     /* */
     p_data->i_buffer = i_ret * sizeof(MPC_SAMPLE_FORMAT) * p_sys->info.channels;
@@ -258,15 +315,27 @@ static int Control( demux_t *p_demux, int i_query, va_list args )
 
         case DEMUX_GET_LENGTH:
             pi64 = (int64_t*)va_arg( args, int64_t * );
+#ifndef HAVE_MPC_MPCDEC_H
             *pi64 = INT64_C(1000000) * p_sys->info.pcm_samples /
                         p_sys->info.sample_freq;
+#else
+	    *pi64 = INT64_C(1000000) * (p_sys->info.samples -
+					p_sys->info.beg_silence) /
+		p_sys->info.sample_freq;
+#endif
             return VLC_SUCCESS;
 
         case DEMUX_GET_POSITION:
             pf = (double*)va_arg( args, double * );
+#ifndef HAVE_MPC_MPCDEC_H
             if( p_sys->info.pcm_samples > 0 )
                 *pf = (double) p_sys->i_position /
                       (double)p_sys->info.pcm_samples;
+#else
+	    if( p_sys->info.samples - p_sys->info.beg_silence > 0)
+		*pf = (double) p_sys->i_position /
+                      (double)(p_sys->info.samples - p_sys->info.beg_silence);
+#endif
             else
                 *pf = 0.0;
             return VLC_SUCCESS;
@@ -279,8 +348,14 @@ static int Control( demux_t *p_demux, int i_query, va_list args )
 
         case DEMUX_SET_POSITION:
             f = (double)va_arg( args, double );
+#ifndef HAVE_MPC_MPCDEC_H
             i64 = (int64_t)(f * p_sys->info.pcm_samples);
             if( mpc_decoder_seek_sample( &p_sys->decoder, i64 ) )
+#else
+            i64 = (int64_t)(f * (p_sys->info.samples -
+				 p_sys->info.beg_silence));
+	    if( mpc_demux_seek_sample( p_sys->decoder, i64 ) == MPC_STATUS_OK )
+#endif
             {
                 p_sys->i_position = i64;
                 return VLC_SUCCESS;
@@ -289,7 +364,11 @@ static int Control( demux_t *p_demux, int i_query, va_list args )
 
         case DEMUX_SET_TIME:
             i64 = (int64_t)va_arg( args, int64_t );
+#ifndef HAVE_MPC_MPCDEC_H
             if( mpc_decoder_seek_sample( &p_sys->decoder, i64 ) )
+#else
+	    if( mpc_demux_seek_sample( p_sys->decoder, i64 ) == MPC_STATUS_OK )
+#endif
             {
                 p_sys->i_position = i64;
                 return VLC_SUCCESS;
@@ -301,33 +380,63 @@ static int Control( demux_t *p_demux, int i_query, va_list args )
     }
 }
 
+#ifndef HAVE_MPC_MPCDEC_H
 mpc_int32_t ReaderRead( void *p_private, void *dst, mpc_int32_t i_size )
 {
     demux_t *p_demux = (demux_t*)p_private;
+#else
+mpc_int32_t ReaderRead( mpc_reader *p_private, void *dst, mpc_int32_t i_size )
+{
+    demux_t *p_demux = (demux_t*)p_private->data;
+#endif
     return stream_Read( p_demux->s, dst, i_size );
 }
 
+#ifndef HAVE_MPC_MPCDEC_H
 mpc_bool_t ReaderSeek( void *p_private, mpc_int32_t i_offset )
 {
     demux_t *p_demux = (demux_t*)p_private;
+#else
+mpc_bool_t ReaderSeek( mpc_reader *p_private, mpc_int32_t i_offset )
+{
+    demux_t *p_demux = (demux_t*)p_private->data;
+#endif
     return !stream_Seek( p_demux->s, i_offset );
 }
 
+#ifndef HAVE_MPC_MPCDEC_H
 mpc_int32_t ReaderTell( void *p_private)
 {
     demux_t *p_demux = (demux_t*)p_private;
+#else
+mpc_int32_t ReaderTell( mpc_reader *p_private)
+{
+    demux_t *p_demux = (demux_t*)p_private->data;
+#endif
     return stream_Tell( p_demux->s );
 }
 
+#ifndef HAVE_MPC_MPCDEC_H
 mpc_int32_t ReaderGetSize( void *p_private )
 {
     demux_t *p_demux = (demux_t*)p_private;
+#else
+mpc_int32_t ReaderGetSize( mpc_reader *p_private )
+{
+    demux_t *p_demux = (demux_t*)p_private->data;
+#endif
     return stream_Size( p_demux->s );
 }
 
+#ifndef HAVE_MPC_MPCDEC_H
 mpc_bool_t ReaderCanSeek( void *p_private )
 {
     demux_t *p_demux = (demux_t*)p_private;
+#else
+mpc_bool_t ReaderCanSeek( mpc_reader *p_private )
+{
+    demux_t *p_demux = (demux_t*)p_private->data;
+#endif
     bool b_canseek;
 
     stream_Control( p_demux->s, STREAM_CAN_SEEK, &b_canseek );
